/**
 * Copyright 2019 IBM Corp. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/// <reference types="node" />
import { OutgoingHttpHeaders } from 'http';
import { RequestWrapper } from '../../lib/request-wrapper';
export declare type TokenManagerOptions = {
    url?: string;
    headers?: OutgoingHttpHeaders;
    disableSslVerification?: boolean;
    /** Allow additional request config parameters */
    [propName: string]: any;
};
export declare class JwtTokenManager {
    protected url: string;
    protected tokenName: string;
    protected disableSslVerification: boolean;
    protected headers: OutgoingHttpHeaders;
    protected requestWrapperInstance: RequestWrapper;
    private tokenInfo;
    private expireTime;
    /**
     * Token Manager Service
     *
     * Retreives and stores JSON web tokens.
     *
     * @param {Object} options
     * @param {String} options.url - url of the api to retrieve tokens from
     * @param {String} [options.accessToken] - user-managed access token
     * @constructor
     */
    constructor(options: TokenManagerOptions);
    /**
     * This function returns a Promise that resolves with an access token, if successful.
     * The source of the token is determined by the following logic:
     * 1. If user provides their own managed access token, assume it is valid and send it
     * 2. a) If this class is managing tokens and does not yet have one, make a request for one
     *    b) If this class is managing tokens and the token has expired, request a new one
     * 3. If this class is managing tokens and has a valid token stored, send it
     *
     */
    getToken(): Promise<any>;
    /**
     * Setter for the disableSslVerification property.
     *
     * @param {boolean} value - the new value for the disableSslVerification property
     * @returns {void}
     */
    setDisableSslVerification(value: boolean): void;
    /**
     * Set a completely new set of headers.
     *
     * @param {OutgoingHttpHeaders} headers - the new set of headers as an object
     * @returns {void}
     */
    setHeaders(headers: OutgoingHttpHeaders): void;
    /**
     * Request a JWT using an API key.
     *
     * @returns {Promise}
     */
    protected requestToken(): Promise<any>;
    /**
     * Check if currently stored token is "expired"
     * i.e. past the window to request a new token
     *
     * @private
     * @returns {boolean}
     */
    private isTokenExpired;
    /**
     * Save the JWT service response and the calculated expiration time to the object's state.
     *
     * @param tokenResponse - Response object from JWT service request
     * @private
     * @returns {void}
     */
    private saveTokenInfo;
    /**
     * Decode the access token and calculate the time to request a new token.
     *
     * A time buffer prevents the edge case of the token expiring before the request could be made.
     * The buffer will be a fraction of the total time to live - we are using 80%
     *
     * @param accessToken - JSON Web Token received from the service
     * @private
     * @returns {void}
     */
    private calculateTimeForNewToken;
}
