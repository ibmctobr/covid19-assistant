"use strict";
/**
 * Copyright 2014 IBM Corp. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var axios_1 = require("axios");
var extend = require("extend");
var FormData = require("form-data");
var https = require("https");
var querystring = require("querystring");
var helper_1 = require("./helper");
var logger_1 = require("./logger");
var isBrowser = typeof window === 'object';
var globalTransactionId = 'x-global-transaction-id';
// Limit the type of axios configs to be customizable
var allowedAxiosConfig = ['transformRequest', 'transformResponse', 'paramsSerializer', 'paramsSerializer', 'timeout', 'withCredentials', 'adapter', 'responseType', 'responseEncoding', 'xsrfCookieName', 'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'maxContentLength', 'validateStatus', 'maxRedirects', 'socketPath', 'httpAgent', 'httpsAgent', 'proxy', 'cancelToken'];
var RequestWrapper = /** @class */ (function () {
    function RequestWrapper(axiosOptions) {
        axiosOptions = axiosOptions || {};
        // override several axios defaults
        // axios sets the default Content-Type for `post`, `put`, and `patch` operations
        // to 'application/x-www-form-urlencoded'. This causes problems, so overriding the
        // defaults here
        var axiosConfig = {
            httpsAgent: new https.Agent({
                // disableSslVerification is the parameter we expose to the user,
                // it is the opposite of rejectUnauthorized
                rejectUnauthorized: !axiosOptions.disableSslVerification
            }),
            maxContentLength: Infinity,
            headers: {
                post: {
                    'Content-Type': 'application/json'
                },
                put: {
                    'Content-Type': 'application/json'
                },
                patch: {
                    'Content-Type': 'application/json'
                },
            }
        };
        // merge valid Axios Config into default.
        extend(true, axiosConfig, allowedAxiosConfig.reduce(function (reducedConfig, key) {
            reducedConfig[key] = axiosOptions[key];
            return reducedConfig;
        }, {}));
        this.axiosInstance = axios_1.default.create(axiosConfig);
        // set debug interceptors
        if (process.env.NODE_DEBUG === 'axios' || process.env.DEBUG) {
            this.axiosInstance.interceptors.request.use(function (config) {
                logger_1.default.debug('Request:');
                try {
                    logger_1.default.debug(JSON.stringify(config, null, 2));
                }
                catch (_a) {
                    logger_1.default.error(config);
                }
                return config;
            }, function (error) {
                logger_1.default.error('Error: ');
                try {
                    logger_1.default.error(JSON.stringify(error, null, 2));
                }
                catch (_a) {
                    logger_1.default.error(error);
                }
                return Promise.reject(error);
            });
            this.axiosInstance.interceptors.response.use(function (response) {
                logger_1.default.debug('Response:');
                try {
                    logger_1.default.debug(JSON.stringify(response, null, 2));
                }
                catch (_a) {
                    logger_1.default.error(response);
                }
                return response;
            }, function (error) {
                logger_1.default.error('Error: ');
                try {
                    logger_1.default.error(JSON.stringify(error, null, 2));
                }
                catch (_a) {
                    logger_1.default.error(error);
                }
                return Promise.reject(error);
            });
        }
    }
    /**
     * Creates the request.
     * 1. Merge default options with user provided options
     * 2. Checks for missing parameters
     * 3. Encode path and query parameters
     * 4. Call the api
     * @private
     * @returns {ReadableStream|undefined}
     * @throws {Error}
     */
    RequestWrapper.prototype.sendRequest = function (parameters) {
        var _this = this;
        var options = extend(true, {}, parameters.defaultOptions, parameters.options);
        var path = options.path, body = options.body, form = options.form, formData = options.formData, qs = options.qs, method = options.method, serviceUrl = options.serviceUrl;
        var headers = options.headers, url = options.url;
        var multipartForm = new FormData();
        // Form params
        if (formData) {
            Object.keys(formData).forEach(function (key) {
                var values = Array.isArray(formData[key]) ? formData[key] : [formData[key]];
                // Skip keys with undefined/null values or empty object value
                values.filter(function (v) { return v != null && !helper_1.isEmptyObject(v); }).forEach(function (value) {
                    // Special case of empty file object
                    if (value.hasOwnProperty('contentType') && !value.hasOwnProperty('data')) {
                        return;
                    }
                    if (helper_1.isFileWithMetadata(value)) {
                        var fileObj = helper_1.buildRequestFileObject(value);
                        multipartForm.append(key, fileObj.value, fileObj.options);
                    }
                    else {
                        if (typeof value === 'object' && !helper_1.isFileData(value)) {
                            value = JSON.stringify(value);
                        }
                        multipartForm.append(key, value);
                    }
                });
            });
        }
        // Path params
        url = parsePath(url, path);
        // Headers
        options.headers = extend({}, options.headers);
        // Convert array-valued query params to strings
        if (qs && Object.keys(qs).length > 0) {
            Object.keys(qs).forEach(function (key) { return Array.isArray(qs[key]) && (qs[key] = qs[key].join(',')); });
        }
        // Add service default endpoint if options.url start with /
        if (url && url.charAt(0) === '/') {
            url = serviceUrl + url;
        }
        var data = body;
        if (form) {
            data = querystring.stringify(form);
            headers['Content-type'] = 'application/x-www-form-urlencoded';
        }
        if (formData) {
            data = multipartForm;
            // form-data generates headers that MUST be included or the request will fail
            headers = extend(true, {}, headers, multipartForm.getHeaders());
        }
        // TEMPORARY: Disabling gzipping due to bug in axios until fix is released:
        // https://github.com/axios/axios/pull/1129
        // accept gzip encoded responses if Accept-Encoding is not already set
        // headers['Accept-Encoding'] = headers['Accept-Encoding'] || 'gzip';
        var requestParams = {
            url: url,
            method: method,
            headers: headers,
            params: qs,
            data: data,
            responseType: options.responseType || 'json',
            paramsSerializer: function (params) {
                return querystring.stringify(params);
            },
        };
        return this.axiosInstance(requestParams).then(function (res) {
            // sometimes error responses will still trigger the `then` block - escape that behavior here
            if (!res) {
                return;
            }
            ;
            // these objects contain circular json structures and are not always relevant to the user
            // if the user wants them, they can be accessed through the debug properties
            delete res.config;
            delete res.request;
            // the other sdks use the interface `result` for the body
            res.result = res.data;
            delete res.data;
            // return another promise that resolves with 'res' to be handled in generated code
            return res;
        }, function (err) {
            // return another promise that rejects with 'err' to be handled in generated code
            throw _this.formatError(err);
        });
    };
    /**
     * Format error returned by axios
     * @param  {object} the object returned by axios via rejection
     * @private
     * @returns {Error}
     */
    RequestWrapper.prototype.formatError = function (axiosError) {
        // return an actual error object,
        // but make it flexible so we can add properties like 'body'
        var error = new Error();
        // axios specific handling
        // this branch is for an error received from the service
        if (axiosError.response) {
            axiosError = axiosError.response;
            // The request was made and the server responded with a status code
            // that falls out of the range of 2xx
            delete axiosError.config;
            delete axiosError.request;
            error.name = axiosError.statusText;
            error.code = axiosError.status;
            error.message = parseServiceErrorMessage(axiosError.data) || axiosError.statusText;
            // some services bury the useful error message within 'data'
            // adding it to the error under the key 'body' as a string or object
            var errorBody = void 0;
            try {
                // try/catch to handle objects with circular references
                errorBody = JSON.stringify(axiosError.data);
            }
            catch (e) {
                // ignore the error, use the object, and tack on a warning
                errorBody = axiosError.data;
                errorBody.warning = 'Body contains circular reference';
                logger_1.default.error("Failed to stringify axiosError: " + e);
            }
            error.body = errorBody;
            // attach headers to error object
            error.headers = axiosError.headers;
            // print a more descriptive error message for auth issues
            if (isAuthenticationError(axiosError)) {
                error.message = 'Access is denied due to invalid credentials.';
            }
        }
        else if (axiosError.request) {
            // The request was made but no response was received
            // `error.request` is an instance of XMLHttpRequest in the browser and an instance of
            // http.ClientRequest in node.js
            error.message = axiosError.message;
            error.statusText = axiosError.code;
            error.body = 'Response not received - no connection was made to the service.';
            // when a request to a private cloud instance has an ssl problem, it never connects and follows this branch of the error handling
            if (isSelfSignedCertificateError(axiosError)) {
                error.message = "The connection failed because the SSL certificate is not valid. " +
                    "To use a self-signed certificate, set the `disableSslVerification` parameter in the constructor options.";
            }
        }
        else {
            // Something happened in setting up the request that triggered an Error
            error.message = axiosError.message;
        }
        return error;
    };
    return RequestWrapper;
}());
exports.RequestWrapper = RequestWrapper;
/**
 * @private
 * @param {string} path
 * @param {Object} params
 * @returns {string}
 */
function parsePath(path, params) {
    if (!path || !params) {
        return path;
    }
    return Object.keys(params).reduce(function (parsedPath, param) {
        var value = encodeURIComponent(params[param]);
        return parsedPath.replace(new RegExp("{" + param + "}"), value);
    }, path);
}
/**
 * Determine if the error is due to bad credentials
 * @private
 * @param {Object} error - error object returned from axios
 * @returns {boolean} true if error is due to authentication
 */
function isAuthenticationError(error) {
    var isAuthErr = false;
    var code = error.status || null;
    var body = error.data || {};
    // handle specific error from iam service, should be relevant across platforms
    var isIamServiceError = body.context &&
        body.context.url &&
        body.context.url.indexOf('iam') > -1;
    if (code === 401 || code === 403 || isIamServiceError) {
        isAuthErr = true;
    }
    return isAuthErr;
}
/**
 * Determine if the error is due to a bad self signed certificate
 * @private
 * @param {Object} error - error object returned from axios
 * @returns {boolean} true if error is due to an SSL error
 */
function isSelfSignedCertificateError(error) {
    var result = false;
    var sslCode = 'DEPTH_ZERO_SELF_SIGNED_CERT';
    var sslMessage = 'self signed certificate';
    var hasSslCode = error.code === sslCode;
    var hasSslMessage = hasStringProperty(error, 'message') && error.message.includes(sslMessage);
    if (hasSslCode || hasSslMessage) {
        result = true;
    }
    return result;
}
/**
 * Return true if object has a specified property that is a string
 * @private
 * @param {Object} obj - object to look for property in
 * @param {string} property - name of the property to look for
 * @returns {boolean} true if property exists and is string
 */
function hasStringProperty(obj, property) {
    return Boolean(obj[property] && typeof obj[property] === 'string');
}
/**
 * Look for service error message in common places, by priority
 * first look in `errors[0].message`, then in `error`, then in
 * `message`, then in `errorMessage`
 * @private
 * @param {Object} response - error response body received from service
 * @returns {string | undefined} the error message if is was found, undefined otherwise
 */
function parseServiceErrorMessage(response) {
    var message;
    if (Array.isArray(response.errors) && response.errors.length > 0 && hasStringProperty(response.errors[0], 'message')) {
        message = response.errors[0].message;
    }
    else if (hasStringProperty(response, 'error')) {
        message = response.error;
    }
    else if (hasStringProperty(response, 'message')) {
        message = response.message;
    }
    else if (hasStringProperty(response, 'errorMessage')) {
        message = response.errorMessage;
    }
    logger_1.default.info("Parsing service error message: " + message);
    return message;
}
//# sourceMappingURL=request-wrapper.js.map